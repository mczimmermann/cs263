// CRITICAL: config.h MUST be included first before any system headers
extern "C" {
#include "config.h"
}

#include <benchmark/benchmark.h>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <vector>
#include <random>

// Use C headers directly to avoid conflicts with coreutils headers
extern "C" {
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <time.h>
}

static const char* TEMP_DIR = "/tmp";

// Global counter for unique output prefixes
static int g_iteration_counter = 0;

// Declare the sort_main function from sort.c
extern "C" int sort_main(int argc, char** argv);

// Helper function to create a file with random lines
static std::string CreateRandomLines(size_t num_lines, size_t line_length) {
    std::string template_str = std::string(TEMP_DIR) + "/sort_bench_XXXXXX";
    char* filename = strdup(template_str.c_str());
    int fd = mkstemp(filename);
    if (fd == -1) {
        perror("mkstemp failed");
        free(filename);
        return "";
    }
    
    std::mt19937 rng(42); // Fixed seed for reproducibility
    std::uniform_int_distribution<int> dist('A', 'z');
    
    for (size_t i = 0; i < num_lines; i++) {
        std::string line;
        for (size_t j = 0; j < line_length; j++) {
            char c = dist(rng);
            line += c;
        }
        line += '\n';
        write(fd, line.c_str(), line.length());
    }
    
    close(fd);
    std::string result(filename);
    free(filename);
    return result;
}

// Helper function to create a file with numeric lines
static std::string CreateNumericLines(size_t num_lines) {
    std::string template_str = std::string(TEMP_DIR) + "/sort_bench_XXXXXX";
    char* filename = strdup(template_str.c_str());
    int fd = mkstemp(filename);
    if (fd == -1) {
        perror("mkstemp failed");
        free(filename);
        return "";
    }
    
    std::mt19937 rng(42);
    std::uniform_int_distribution<int> dist(-1000000, 1000000);
    
    for (size_t i = 0; i < num_lines; i++) {
        std::string line = std::to_string(dist(rng)) + "\n";
        write(fd, line.c_str(), line.length());
    }
    
    close(fd);
    std::string result(filename);
    free(filename);
    return result;
}

// Helper function to create a reverse-sorted file
static std::string CreateReverseSorted(size_t num_lines) {
    std::string template_str = std::string(TEMP_DIR) + "/sort_bench_XXXXXX";
    char* filename = strdup(template_str.c_str());
    int fd = mkstemp(filename);
    if (fd == -1) {
        perror("mkstemp failed");
        free(filename);
        return "";
    }
    
    for (size_t i = num_lines; i > 0; i--) {
        char buf[64];
        snprintf(buf, sizeof(buf), "line_%08zu\n", i - 1);
        write(fd, buf, strlen(buf));
    }
    
    close(fd);
    std::string result(filename);
    free(filename);
    return result;
}

// Helper function to create already-sorted files for merge test
static std::vector<std::string> CreateSortedFiles(size_t num_files, size_t lines_per_file) {
    std::vector<std::string> files;
    
    for (size_t f = 0; f < num_files; f++) {
        std::string template_str = std::string(TEMP_DIR) + "/sort_bench_XXXXXX";
        char* filename = strdup(template_str.c_str());
        int fd = mkstemp(filename);
        if (fd == -1) {
            perror("mkstemp failed");
            free(filename);
            continue;
        }
        
        for (size_t i = 0; i < lines_per_file; i++) {
            char buf[64];
            snprintf(buf, sizeof(buf), "line_%08zu\n", f * lines_per_file + i);
            write(fd, buf, strlen(buf));
        }
        
        close(fd);
        files.push_back(std::string(filename));
        free(filename);
    }
    
    return files;
}

// Helper to execute sort as a library function in a forked process
static bool ExecuteSortLib(const std::vector<std::string>& args, benchmark::State& state) {
    std::vector<char*> argv;
    for (const auto& arg : args) {
        argv.push_back(const_cast<char*>(arg.c_str()));
    }
    argv.push_back(nullptr);
    
    // Create pipe for timing communication
    int pipefd[2];
    if (pipe(pipefd) == -1) {
        state.SkipWithError("pipe failed");
        return false;
    }
    
    state.PauseTiming();
    
    pid_t pid = fork();
    if (pid == -1) {
        close(pipefd[0]);
        close(pipefd[1]);
        state.SkipWithError("fork failed");
        return false;
    }
    
    if (pid == 0) {
        close(pipefd[0]);
        
        struct timespec start, end;
        clock_gettime(CLOCK_MONOTONIC, &start);
        
        int result = sort_main(argv.size() - 1, argv.data());
        
        clock_gettime(CLOCK_MONOTONIC, &end);
        
        int64_t elapsed_ns = (end.tv_sec - start.tv_sec) * 1000000000LL + 
                             (end.tv_nsec - start.tv_nsec);
        
        write(pipefd[1], &elapsed_ns, sizeof(elapsed_ns));
        close(pipefd[1]);
        
        _exit(result);
    }
    
    close(pipefd[1]);
    
    int64_t elapsed_ns;
    ssize_t bytes_read = read(pipefd[0], &elapsed_ns, sizeof(elapsed_ns));
    close(pipefd[0]);
    
    int status;
    if (waitpid(pid, &status, 0) == -1) {
        state.SkipWithError("waitpid failed");
        return false;
    }
    
    if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
        state.SkipWithError("sort command failed");
        return false;
    }
    
    if (bytes_read != sizeof(elapsed_ns)) {
        state.SkipWithError("failed to read timing from child");
        return false;
    }
    
    state.SetIterationTime(elapsed_ns / 1e9);
    state.ResumeTiming();
    
    return true;
}

// Benchmark: sort random lines
static void BM_SortRandom(benchmark::State& state) {
    size_t num_lines = state.range(0);
    size_t line_length = 50;
    size_t file_size = num_lines * (line_length + 1);
    
    for (auto _ : state) {
        state.PauseTiming();
        std::string input_file = CreateRandomLines(num_lines, line_length);
        if (input_file.empty()) {
            state.SkipWithError("Failed to create test file");
            return;
        }
        
        char output_buf[256];
        snprintf(output_buf, sizeof(output_buf), "%s/sort_out_%d.txt", TEMP_DIR, g_iteration_counter++);
        std::string output_file = output_buf;
        
        std::vector<std::string> args = {
            "sort",
            "-o", output_file,
            input_file
        };
        
        if (!ExecuteSortLib(args, state)) {
            unlink(input_file.c_str());
            unlink(output_file.c_str());
            return;
        }
        
        unlink(input_file.c_str());
        unlink(output_file.c_str());
    }
    
    state.SetBytesProcessed(state.iterations() * file_size);
}

// Benchmark: sort numeric
static void BM_SortNumeric(benchmark::State& state) {
    size_t num_lines = state.range(0);
    size_t file_size = num_lines * 12; // Approximate
    
    for (auto _ : state) {
        state.PauseTiming();
        std::string input_file = CreateNumericLines(num_lines);
        if (input_file.empty()) {
            state.SkipWithError("Failed to create test file");
            return;
        }
        
        char output_buf[256];
        snprintf(output_buf, sizeof(output_buf), "%s/sort_out_%d.txt", TEMP_DIR, g_iteration_counter++);
        std::string output_file = output_buf;
        
        std::vector<std::string> args = {
            "sort",
            "-n",
            "-o", output_file,
            input_file
        };
        
        if (!ExecuteSortLib(args, state)) {
            unlink(input_file.c_str());
            unlink(output_file.c_str());
            return;
        }
        
        unlink(input_file.c_str());
        unlink(output_file.c_str());
    }
    
    state.SetBytesProcessed(state.iterations() * file_size);
}

// Benchmark: sort reverse
static void BM_SortReverse(benchmark::State& state) {
    size_t num_lines = state.range(0);
    size_t file_size = num_lines * 20;
    
    for (auto _ : state) {
        state.PauseTiming();
        std::string input_file = CreateReverseSorted(num_lines);
        if (input_file.empty()) {
            state.SkipWithError("Failed to create test file");
            return;
        }
        
        char output_buf[256];
        snprintf(output_buf, sizeof(output_buf), "%s/sort_out_%d.txt", TEMP_DIR, g_iteration_counter++);
        std::string output_file = output_buf;
        
        std::vector<std::string> args = {
            "sort",
            "-r",
            "-o", output_file,
            input_file
        };
        
        if (!ExecuteSortLib(args, state)) {
            unlink(input_file.c_str());
            unlink(output_file.c_str());
            return;
        }
        
        unlink(input_file.c_str());
        unlink(output_file.c_str());
    }
    
    state.SetBytesProcessed(state.iterations() * file_size);
}

// Benchmark: sort unique
static void BM_SortUnique(benchmark::State& state) {
    size_t num_lines = state.range(0);
    size_t file_size = num_lines * 60;
    
    for (auto _ : state) {
        state.PauseTiming();
        std::string input_file = CreateRandomLines(num_lines, 50);
        if (input_file.empty()) {
            state.SkipWithError("Failed to create test file");
            return;
        }
        
        char output_buf[256];
        snprintf(output_buf, sizeof(output_buf), "%s/sort_out_%d.txt", TEMP_DIR, g_iteration_counter++);
        std::string output_file = output_buf;
        
        std::vector<std::string> args = {
            "sort",
            "-u",
            "-o", output_file,
            input_file
        };
        
        if (!ExecuteSortLib(args, state)) {
            unlink(input_file.c_str());
            unlink(output_file.c_str());
            return;
        }
        
        unlink(input_file.c_str());
        unlink(output_file.c_str());
    }
    
    state.SetBytesProcessed(state.iterations() * file_size);
}

// Benchmark: merge sorted files
static void BM_SortMerge(benchmark::State& state) {
    size_t lines_per_file = state.range(0);
    size_t file_size = lines_per_file * 60 * 3; // 3 files
    
    for (auto _ : state) {
        state.PauseTiming();
        std::vector<std::string> input_files = CreateSortedFiles(3, lines_per_file);
        if (input_files.size() != 3) {
            state.SkipWithError("Failed to create test files");
            return;
        }
        
        char output_buf[256];
        snprintf(output_buf, sizeof(output_buf), "%s/sort_out_%d.txt", TEMP_DIR, g_iteration_counter++);
        std::string output_file = output_buf;
        
        std::vector<std::string> args = {
            "sort",
            "-m",
            "-o", output_file
        };
        for (const auto& f : input_files) {
            args.push_back(f);
        }
        
        if (!ExecuteSortLib(args, state)) {
            for (const auto& f : input_files) {
                unlink(f.c_str());
            }
            unlink(output_file.c_str());
            return;
        }
        
        for (const auto& f : input_files) {
            unlink(f.c_str());
        }
        unlink(output_file.c_str());
    }
    
    state.SetBytesProcessed(state.iterations() * file_size);
}

// Register benchmarks
BENCHMARK(BM_SortRandom)
    ->Arg(10000)       // 10K lines
    ->Arg(100000)      // 100K lines
    ->Arg(1000000)     // 1M lines
    ->Unit(benchmark::kMillisecond)
    ->UseManualTime();

BENCHMARK(BM_SortNumeric)
    ->Arg(10000)
    ->Arg(100000)
    ->Arg(1000000)
    ->Unit(benchmark::kMillisecond)
    ->UseManualTime();

BENCHMARK(BM_SortReverse)
    ->Arg(10000)
    ->Arg(100000)
    ->Arg(1000000)
    ->Unit(benchmark::kMillisecond)
    ->UseManualTime();

BENCHMARK(BM_SortUnique)
    ->Arg(10000)
    ->Arg(100000)
    ->Arg(1000000)
    ->Unit(benchmark::kMillisecond)
    ->UseManualTime();

BENCHMARK(BM_SortMerge)
    ->Arg(10000)       // 10K lines per file, 3 files
    ->Arg(100000)      // 100K lines per file, 3 files
    ->Unit(benchmark::kMillisecond)
    ->UseManualTime();

int main(int argc, char** argv) {
    ::benchmark::Initialize(&argc, argv);
    if (::benchmark::ReportUnrecognizedArguments(argc, argv)) return 1;
    ::benchmark::RunSpecifiedBenchmarks();
    ::benchmark::Shutdown();
    return 0;
}