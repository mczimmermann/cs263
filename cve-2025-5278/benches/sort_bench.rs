use criterion::{criterion_group, criterion_main, Criterion, BenchmarkId, Throughput};
use std::ffi::OsString;
use std::fs::File;
use std::io::Write;
use tempfile::TempDir;
use uu_sort::uumain;

fn generate_random_lines(num_lines: usize, line_length: usize) -> (TempDir, std::path::PathBuf) {
    use rand::{Rng, SeedableRng};
    use rand::rngs::StdRng;
    
    let dir = TempDir::new().unwrap();
    let path = dir.path().join("input.txt");
    let mut file = File::create(&path).unwrap();
    
    let mut rng = StdRng::seed_from_u64(42); // Fixed seed for reproducibility
    
    for _ in 0..num_lines {
        let line: String = (0..line_length)
            .map(|_| rng.sample(rand::distributions::Alphanumeric) as char)
            .collect();
        writeln!(file, "{}", line).unwrap();
    }
    
    (dir, path)
}

fn generate_numeric_lines(num_lines: usize) -> (TempDir, std::path::PathBuf) {
    use rand::{Rng, SeedableRng};
    use rand::rngs::StdRng;
    
    let dir = TempDir::new().unwrap();
    let path = dir.path().join("input.txt");
    let mut file = File::create(&path).unwrap();
    
    let mut rng = StdRng::seed_from_u64(42);
    
    for _ in 0..num_lines {
        let num: i64 = rng.gen_range(-1000000..1000000);
        writeln!(file, "{}", num).unwrap();
    }
    
    (dir, path)
}

fn generate_reverse_sorted(num_lines: usize) -> (TempDir, std::path::PathBuf) {
    let dir = TempDir::new().unwrap();
    let path = dir.path().join("input.txt");
    let mut file = File::create(&path).unwrap();
    
    for i in (0..num_lines).rev() {
        writeln!(file, "line_{:08}", i).unwrap();
    }
    
    (dir, path)
}

fn bench_sort_random(c: &mut Criterion) {
    let mut group = c.benchmark_group("sort_random");
    
    let params = [
        (10000, 50),      // 10K lines, 50 chars each (~500KB)
        (100000, 50),     // 100K lines, 50 chars each (~5MB)
        (1000000, 50),    // 1M lines, 50 chars each (~50MB)
    ];
    
    for (num_lines, line_length) in params.iter() {
        let file_size = num_lines * (line_length + 1); // +1 for newline
        group.throughput(Throughput::Bytes(file_size as u64));
        
        group.bench_with_input(
            BenchmarkId::from_parameter(format!("{}K_lines", num_lines / 1000)),
            &(*num_lines, *line_length),
            |b, &(lines, len)| {
                let (_dir, input_file) = generate_random_lines(lines, len);
                b.iter(|| {
                    let output_dir = TempDir::new().unwrap();
                    let output_file = output_dir.path().join("output.txt");
                    let args: Vec<OsString> = vec![
                        "sort".into(),
                        "-o".into(),
                        output_file.as_os_str().into(),
                        input_file.as_os_str().into(),
                    ];
                    let _ = uumain(args.into_iter());
                });
            },
        );
    }
    
    group.finish();
}

fn bench_sort_numeric(c: &mut Criterion) {
    let mut group = c.benchmark_group("sort_numeric");
    
    let params = [
        10000,      // 10K lines
        100000,     // 100K lines
        1000000,    // 1M lines
    ];
    
    for num_lines in params.iter() {
        let file_size = num_lines * 12; // Approximate size with numbers
        group.throughput(Throughput::Bytes(file_size as u64));
        
        group.bench_with_input(
            BenchmarkId::from_parameter(format!("{}K_lines", num_lines / 1000)),
            num_lines,
            |b, &lines| {
                let (_dir, input_file) = generate_numeric_lines(lines);
                b.iter(|| {
                    let output_dir = TempDir::new().unwrap();
                    let output_file = output_dir.path().join("output.txt");
                    let args: Vec<OsString> = vec![
                        "sort".into(),
                        "-n".into(),
                        "-o".into(),
                        output_file.as_os_str().into(),
                        input_file.as_os_str().into(),
                    ];
                    let _ = uumain(args.into_iter());
                });
            },
        );
    }
    
    group.finish();
}

fn bench_sort_reverse(c: &mut Criterion) {
    let mut group = c.benchmark_group("sort_reverse");
    
    let params = [
        10000,      // 10K lines
        100000,     // 100K lines
        1000000,    // 1M lines
    ];
    
    for num_lines in params.iter() {
        let file_size = num_lines * 20; // "line_" + 8 digits + newline
        group.throughput(Throughput::Bytes(file_size as u64));
        
        group.bench_with_input(
            BenchmarkId::from_parameter(format!("{}K_lines", num_lines / 1000)),
            num_lines,
            |b, &lines| {
                let (_dir, input_file) = generate_reverse_sorted(lines);
                b.iter(|| {
                    let output_dir = TempDir::new().unwrap();
                    let output_file = output_dir.path().join("output.txt");
                    let args: Vec<OsString> = vec![
                        "sort".into(),
                        "-r".into(),
                        "-o".into(),
                        output_file.as_os_str().into(),
                        input_file.as_os_str().into(),
                    ];
                    let _ = uumain(args.into_iter());
                });
            },
        );
    }
    
    group.finish();
}

fn bench_sort_unique(c: &mut Criterion) {
    let mut group = c.benchmark_group("sort_unique");
    
    let params = [
        10000,      // 10K lines
        100000,     // 100K lines
        1000000,    // 1M lines
    ];
    
    for num_lines in params.iter() {
        let file_size = num_lines * 60; // 50 chars + newline
        group.throughput(Throughput::Bytes(file_size as u64));
        
        group.bench_with_input(
            BenchmarkId::from_parameter(format!("{}K_lines", num_lines / 1000)),
            num_lines,
            |b, &lines| {
                let (_dir, input_file) = generate_random_lines(lines, 50);
                b.iter(|| {
                    let output_dir = TempDir::new().unwrap();
                    let output_file = output_dir.path().join("output.txt");
                    let args: Vec<OsString> = vec![
                        "sort".into(),
                        "-u".into(),
                        "-o".into(),
                        output_file.as_os_str().into(),
                        input_file.as_os_str().into(),
                    ];
                    let _ = uumain(args.into_iter());
                });
            },
        );
    }
    
    group.finish();
}

fn bench_sort_merge(c: &mut Criterion) {
    let mut group = c.benchmark_group("sort_merge");
    
    let params = [
        10000,      // 10K lines per file
        100000,     // 100K lines per file
    ];
    
    for num_lines in params.iter() {
        let file_size = num_lines * 60 * 3; // 3 files
        group.throughput(Throughput::Bytes(file_size as u64));
        
        group.bench_with_input(
            BenchmarkId::from_parameter(format!("{}K_lines_x3", num_lines / 1000)),
            num_lines,
            |b, &lines| {
                // Create 3 already-sorted files
                let dir = TempDir::new().unwrap();
                let mut files = Vec::new();
                
                for i in 0..3 {
                    let path = dir.path().join(format!("input{}.txt", i));
                    let mut file = File::create(&path).unwrap();
                    for j in 0..lines {
                        writeln!(file, "line_{:08}", i * lines + j).unwrap();
                    }
                    files.push(path);
                }
                
                b.iter(|| {
                    let output_dir = TempDir::new().unwrap();
                    let output_file = output_dir.path().join("output.txt");
                    let mut args: Vec<OsString> = vec![
                        "sort".into(),
                        "-m".into(),
                        "-o".into(),
                        output_file.as_os_str().into(),
                    ];
                    for f in &files {
                        args.push(f.as_os_str().into());
                    }
                    let _ = uumain(args.into_iter());
                });
            },
        );
    }
    
    group.finish();
}

criterion_group!(
    benches,
    bench_sort_random,
    bench_sort_numeric,
    bench_sort_reverse,
    bench_sort_unique,
    bench_sort_merge
);
criterion_main!(benches);