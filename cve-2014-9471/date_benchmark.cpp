// CRITICAL: config.h MUST be included first before any system headers
extern "C" {
#include "config.h"
}

#include <benchmark/benchmark.h>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <vector>
#include <time.h>

// Use C headers directly to avoid conflicts with coreutils headers
extern "C" {
#include <unistd.h>
#include <sys/wait.h>
}

// System headers for POSIX functions - NOT in extern "C"
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/wait.h>

// Declare the date_main function from date.c
extern "C" int date_main(int argc, char** argv);

// Helper to execute date as a library function in a forked process
// Uses a pipe to get actual timing from child process
static bool ExecuteDateLib(const std::vector<std::string>& args, benchmark::State& state) {
    // Convert to char* array for C function
    std::vector<char*> argv;
    for (const auto& arg : args) {
        argv.push_back(const_cast<char*>(arg.c_str()));
    }
    argv.push_back(nullptr);  // Add NULL terminator
    
    // Create pipe for timing communication
    int pipefd[2];
    if (pipe(pipefd) == -1) {
        state.SkipWithError("pipe failed");
        return false;
    }
    
    state.PauseTiming();  // Don't include fork overhead
    
    // Fork to get a clean process for each date invocation
    pid_t pid = fork();
    if (pid == -1) {
        close(pipefd[0]);
        close(pipefd[1]);
        state.SkipWithError("fork failed");
        return false;
    }
    
    if (pid == 0) {
        // Child process - measure time and send back to parent
        close(pipefd[0]);  // Close read end
        
        // Redirect stdout to /dev/null to avoid output overhead
        int devnull = open("/dev/null", O_WRONLY);
        if (devnull != -1) {
            dup2(devnull, STDOUT_FILENO);
            close(devnull);
        }
        
        struct timespec start, end;
        clock_gettime(CLOCK_MONOTONIC, &start);
        
        int result = date_main(argv.size() - 1, argv.data());
        
        clock_gettime(CLOCK_MONOTONIC, &end);
        
        // Calculate elapsed time in nanoseconds
        int64_t elapsed_ns = (end.tv_sec - start.tv_sec) * 1000000000LL + 
                                (end.tv_nsec - start.tv_nsec);
        
        // Send timing back to parent
        write(pipefd[1], &elapsed_ns, sizeof(elapsed_ns));
        close(pipefd[1]);
        
        _exit(result);  // Use _exit to avoid flushing parent's buffers
    }
    
    // Parent process - read timing from child
    close(pipefd[1]);  // Close write end
    
    int64_t elapsed_ns;
    ssize_t bytes_read = read(pipefd[0], &elapsed_ns, sizeof(elapsed_ns));
    close(pipefd[0]);
    
    // Wait for child to complete
    int status;
    if (waitpid(pid, &status, 0) == -1) {
        state.SkipWithError("waitpid failed");
        return false;
    }
    
    if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
        state.SkipWithError("date command failed");
        return false;
    }
    
    if (bytes_read != sizeof(elapsed_ns)) {
        state.SkipWithError("failed to read timing from child");
        return false;
    }
    
    // Report the actual time spent in date_main
    state.SetIterationTime(elapsed_ns / 1e9);  // Convert to seconds
    state.ResumeTiming();
    
    return true;
}

// Benchmark: Simple date display (default format)
static void BM_DateDefault(benchmark::State& state) {
    for (auto _ : state) {
        std::vector<std::string> args = {"date"};
        
        if (!ExecuteDateLib(args, state)) {
            return;
        }
    }
}

// Benchmark: ISO 8601 format
static void BM_DateISO8601(benchmark::State& state) {
    for (auto _ : state) {
        std::vector<std::string> args = {
            "date",
            "--iso-8601=seconds"
        };
        
        if (!ExecuteDateLib(args, state)) {
            return;
        }
    }
}

// Benchmark: RFC 2822 format
static void BM_DateRFC2822(benchmark::State& state) {
    for (auto _ : state) {
        std::vector<std::string> args = {
            "date",
            "--rfc-2822"
        };
        
        if (!ExecuteDateLib(args, state)) {
            return;
        }
    }
}

// Benchmark: Custom format with multiple components
static void BM_DateCustomFormat(benchmark::State& state) {
    for (auto _ : state) {
        std::vector<std::string> args = {
            "date",
            "+%Y-%m-%d %H:%M:%S.%N %z"
        };
        
        if (!ExecuteDateLib(args, state)) {
            return;
        }
    }
}

// Benchmark: Unix timestamp output
static void BM_DateUnixTimestamp(benchmark::State& state) {
    for (auto _ : state) {
        std::vector<std::string> args = {
            "date",
            "+%s"
        };
        
        if (!ExecuteDateLib(args, state)) {
            return;
        }
    }
}

// Benchmark: Parse and display date string
static void BM_DateParse(benchmark::State& state) {
    for (auto _ : state) {
        std::vector<std::string> args = {
            "date",
            "-d", "2024-01-15 14:30:00"
        };
        
        if (!ExecuteDateLib(args, state)) {
            return;
        }
    }
}

// Benchmark: Parse relative date
static void BM_DateRelative(benchmark::State& state) {
    for (auto _ : state) {
        std::vector<std::string> args = {
            "date",
            "-d", "tomorrow"
        };
        
        if (!ExecuteDateLib(args, state)) {
            return;
        }
    }
}

// Benchmark: Parse complex relative date
static void BM_DateComplexRelative(benchmark::State& state) {
    for (auto _ : state) {
        std::vector<std::string> args = {
            "date",
            "-d", "3 days 2 hours 15 minutes ago"
        };
        
        if (!ExecuteDateLib(args, state)) {
            return;
        }
    }
}

// Benchmark: UTC conversion
static void BM_DateUTC(benchmark::State& state) {
    for (auto _ : state) {
        std::vector<std::string> args = {
            "date",
            "-u"
        };
        
        if (!ExecuteDateLib(args, state)) {
            return;
        }
    }
}

// Benchmark: Reference file timestamp
static void BM_DateReference(benchmark::State& state) {
    // Create a temporary reference file once
    const char* ref_file = "/tmp/date_bench_ref";
    FILE* f = fopen(ref_file, "w");
    if (f) {
        fclose(f);
    }
    
    for (auto _ : state) {
        std::vector<std::string> args = {
            "date",
            "-r", ref_file
        };
        
        if (!ExecuteDateLib(args, state)) {
            unlink(ref_file);
            return;
        }
    }
    
    unlink(ref_file);
}

// Register benchmarks with manual timing
BENCHMARK(BM_DateDefault)
    ->Unit(benchmark::kMicrosecond)
    ->UseManualTime();

BENCHMARK(BM_DateISO8601)
    ->Unit(benchmark::kMicrosecond)
    ->UseManualTime();

BENCHMARK(BM_DateRFC2822)
    ->Unit(benchmark::kMicrosecond)
    ->UseManualTime();

BENCHMARK(BM_DateCustomFormat)
    ->Unit(benchmark::kMicrosecond)
    ->UseManualTime();

BENCHMARK(BM_DateUnixTimestamp)
    ->Unit(benchmark::kMicrosecond)
    ->UseManualTime();

BENCHMARK(BM_DateParse)
    ->Unit(benchmark::kMicrosecond)
    ->UseManualTime();

BENCHMARK(BM_DateRelative)
    ->Unit(benchmark::kMicrosecond)
    ->UseManualTime();

BENCHMARK(BM_DateComplexRelative)
    ->Unit(benchmark::kMicrosecond)
    ->UseManualTime();

BENCHMARK(BM_DateUTC)
    ->Unit(benchmark::kMicrosecond)
    ->UseManualTime();

BENCHMARK(BM_DateReference)
    ->Unit(benchmark::kMicrosecond)
    ->UseManualTime();

int main(int argc, char** argv) {
    ::benchmark::Initialize(&argc, argv);
    if (::benchmark::ReportUnrecognizedArguments(argc, argv)) return 1;
    ::benchmark::RunSpecifiedBenchmarks();
    return 0;
}