#include <benchmark/benchmark.h>
#include <cstdlib>
#include <string>
#include <fstream>
#include <vector>
#include <unistd.h>
#include <sys/wait.h>

// Create test file once before benchmarking
static void CreateTestFile(const std::string& path, size_t size_mb) {
    std::ofstream file(path, std::ios::binary);
    std::vector<char> chunk(1024 * 1024, 'A');
    for (size_t i = 0; i < size_mb; ++i) {
        file.write(chunk.data(), chunk.size());
    }
}

static void BM_GNU_Split(benchmark::State& state) {
    std::string input = "/tmp/input_gnu.bin";
    std::string output_prefix = "/tmp/x_";
    
    // Create input file once, outside the benchmark loop
    CreateTestFile(input, state.range(0));
    
    for (auto _ : state) {
        // Use fork/exec instead of system() to reduce shell overhead
        pid_t pid = fork();
        if (pid == 0) {
            // Child process
            execl("/usr/src/coreutils/src/split", "split", 
                  "-b", "10M", input.c_str(), output_prefix.c_str(), nullptr);
            exit(1); // If exec fails
        } else if (pid > 0) {
            // Parent process - wait for child
            int status;
            waitpid(pid, &status, 0);
        }
        
        // Clean up output files
        std::system("rm -f /tmp/x_*");
    }
    
    // Clean up input file
    std::remove(input.c_str());
}

BENCHMARK(BM_GNU_Split)->Arg(100)->Unit(benchmark::kMillisecond);

BENCHMARK_MAIN();