// CRITICAL: config.h MUST be included first before any system headers
extern "C" {
#include "config.h"
}

#include <benchmark/benchmark.h>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <vector>

// Use C headers directly to avoid conflicts with coreutils headers
extern "C" {
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/wait.h>
}

static const char* TEMP_DIR = "/tmp";

// Global counter for unique output prefixes
static int g_iteration_counter = 0;

// Declare the split_main function from split.c
extern "C" int split_main(int argc, char** argv);

// Helper function to create a temporary test file
static std::string CreateTestFile(size_t size, const char* content_pattern = "test line\n") {
    std::string template_str = std::string(TEMP_DIR) + "/split_bench_XXXXXX";
    char* filename = strdup(template_str.c_str());
    int fd = mkstemp(filename);
    if (fd == -1) {
        perror("mkstemp failed");
        free(filename);
        return "";
    }
    
    size_t pattern_len = strlen(content_pattern);
    size_t written = 0;
    while (written < size) {
        size_t to_write = (pattern_len < size - written) ? pattern_len : size - written;
        ssize_t result = write(fd, content_pattern, to_write);
        if (result < 0) {
            perror("write failed");
            close(fd);
            unlink(filename);
            free(filename);
            return "";
        }
        written += to_write;
    }
    close(fd);
    std::string result(filename);
    free(filename);
    return result;
}

// Helper to clean up test files
static void CleanupFiles(const std::string& pattern) {
    std::string cmd = "rm -f " + pattern + "* 2>/dev/null";
    int ret = system(cmd.c_str());
    (void)ret; // Suppress unused warning
}

// Helper to execute split as a library function in a forked process
// Uses a pipe to get actual timing from child process
static bool ExecuteSplitLib(const std::vector<std::string>& args, benchmark::State& state) {
    // Convert to char* array for C function
    std::vector<char*> argv;
    for (const auto& arg : args) {
        argv.push_back(const_cast<char*>(arg.c_str()));
    }
    argv.push_back(nullptr);  // Add NULL terminator
    
    // Create pipe for timing communication
    int pipefd[2];
    if (pipe(pipefd) == -1) {
        state.SkipWithError("pipe failed");
        return false;
    }
    
    state.PauseTiming();  // Don't include fork overhead
    
    // Fork to get a clean process for each split invocation
    pid_t pid = fork();
    if (pid == -1) {
        close(pipefd[0]);
        close(pipefd[1]);
        state.SkipWithError("fork failed");
        return false;
    }
    
    if (pid == 0) {
        // Child process - measure time and send back to parent
        close(pipefd[0]);  // Close read end
        
        struct timespec start, end;
        clock_gettime(CLOCK_MONOTONIC, &start);
        
        int result = split_main(argv.size() - 1, argv.data());
        
        clock_gettime(CLOCK_MONOTONIC, &end);
        
        // Calculate elapsed time in nanoseconds
        int64_t elapsed_ns = (end.tv_sec - start.tv_sec) * 1000000000LL + 
                                (end.tv_nsec - start.tv_nsec);
        
        // Send timing back to parent
        write(pipefd[1], &elapsed_ns, sizeof(elapsed_ns));
        close(pipefd[1]);
        
        _exit(result);  // Use _exit to avoid flushing parent's buffers
    }
    
    // Parent process - read timing from child
    close(pipefd[1]);  // Close write end
    
    int64_t elapsed_ns;
    ssize_t bytes_read = read(pipefd[0], &elapsed_ns, sizeof(elapsed_ns));
    close(pipefd[0]);
    
    // Wait for child to complete
    int status;
    if (waitpid(pid, &status, 0) == -1) {
        state.SkipWithError("waitpid failed");
        return false;
    }
    
    if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
        state.SkipWithError("split command failed");
        return false;
    }
    
    if (bytes_read != sizeof(elapsed_ns)) {
        state.SkipWithError("failed to read timing from child");
        return false;
    }
    
    // Report the actual time spent in split_main
    state.SetIterationTime(elapsed_ns / 1e9);  // Convert to seconds
    state.ResumeTiming();
    
    return true;
}

// Benchmark: split by lines
static void BM_SplitLines(benchmark::State& state) {
    size_t file_size = state.range(0);
    size_t lines_per_file = state.range(1);
    
    for (auto _ : state) {
        state.PauseTiming();
        std::string input_file = CreateTestFile(file_size);
        if (input_file.empty()) {
            state.SkipWithError("Failed to create test file");
            return;
        }
        
        // Use unique output prefix for each iteration
        char prefix_buf[256];
        snprintf(prefix_buf, sizeof(prefix_buf), "%s/split_out_%d_", TEMP_DIR, g_iteration_counter++);
        std::string output_prefix = prefix_buf;
        
        std::vector<std::string> args = {
            "split",
            "-l", std::to_string(lines_per_file),
            input_file,
            output_prefix
        };
        
        // ExecuteSplitLib will manage timing internally
        if (!ExecuteSplitLib(args, state)) {
            CleanupFiles(output_prefix);
            unlink(input_file.c_str());
            return;
        }
        unlink(input_file.c_str());
        CleanupFiles(output_prefix);
        state.ResumeTiming();
    }
    
    state.SetBytesProcessed(state.iterations() * file_size);
}

// Benchmark: split by bytes
static void BM_SplitBytes(benchmark::State& state) {
    size_t file_size = state.range(0);
    size_t bytes_per_file = state.range(1);
    
    for (auto _ : state) {
        state.PauseTiming();
        std::string input_file = CreateTestFile(file_size);
        if (input_file.empty()) {
            state.SkipWithError("Failed to create test file");
            return;
        }
        
        char prefix_buf[256];
        snprintf(prefix_buf, sizeof(prefix_buf), "%s/split_out_%d_", TEMP_DIR, g_iteration_counter++);
        std::string output_prefix = prefix_buf;
        
        std::vector<std::string> args = {
            "split",
            "-b", std::to_string(bytes_per_file),
            input_file,
            output_prefix
        };
        
        if (!ExecuteSplitLib(args, state)) {
            CleanupFiles(output_prefix);
            unlink(input_file.c_str());
            return;
        }
        unlink(input_file.c_str());
        CleanupFiles(output_prefix);
        state.ResumeTiming();
    }
    
    state.SetBytesProcessed(state.iterations() * file_size);
}

// Benchmark: split by line bytes
static void BM_SplitLineBytes(benchmark::State& state) {
    size_t file_size = state.range(0);
    size_t bytes_per_file = state.range(1);
    
    for (auto _ : state) {
        state.PauseTiming();
        std::string input_file = CreateTestFile(file_size);
        if (input_file.empty()) {
            state.SkipWithError("Failed to create test file");
            return;
        }
        
        char prefix_buf[256];
        snprintf(prefix_buf, sizeof(prefix_buf), "%s/split_out_%d_", TEMP_DIR, g_iteration_counter++);
        std::string output_prefix = prefix_buf;
        
        std::vector<std::string> args = {
            "split",
            "-C", std::to_string(bytes_per_file),
            input_file,
            output_prefix
        };
        
        if (!ExecuteSplitLib(args, state)) {
            CleanupFiles(output_prefix);
            unlink(input_file.c_str());
            return;
        }
        unlink(input_file.c_str());
        CleanupFiles(output_prefix);
        state.ResumeTiming();
    }
    
    state.SetBytesProcessed(state.iterations() * file_size);
}

// Benchmark: split into N chunks
static void BM_SplitChunks(benchmark::State& state) {
    size_t file_size = state.range(0);
    size_t num_chunks = state.range(1);
    
    for (auto _ : state) {
        state.PauseTiming();
        std::string input_file = CreateTestFile(file_size);
        if (input_file.empty()) {
            state.SkipWithError("Failed to create test file");
            return;
        }
        
        char prefix_buf[256];
        snprintf(prefix_buf, sizeof(prefix_buf), "%s/split_out_%d_", TEMP_DIR, g_iteration_counter++);
        std::string output_prefix = prefix_buf;
        
        std::vector<std::string> args = {
            "split",
            "-n", std::to_string(num_chunks),
            input_file,
            output_prefix
        };
        
        if (!ExecuteSplitLib(args, state)) {
            CleanupFiles(output_prefix);
            unlink(input_file.c_str());
            return;
        }
        unlink(input_file.c_str());
        CleanupFiles(output_prefix);
        state.ResumeTiming();
    }
    
    state.SetBytesProcessed(state.iterations() * file_size);
}

// Benchmark: round-robin split
static void BM_SplitRoundRobin(benchmark::State& state) {
    size_t file_size = state.range(0);
    size_t num_files = state.range(1);
    
    for (auto _ : state) {
        state.PauseTiming();
        std::string input_file = CreateTestFile(file_size);
        if (input_file.empty()) {
            state.SkipWithError("Failed to create test file");
            return;
        }
        
        char prefix_buf[256];
        snprintf(prefix_buf, sizeof(prefix_buf), "%s/split_out_%d_", TEMP_DIR, g_iteration_counter++);
        std::string output_prefix = prefix_buf;
        
        std::vector<std::string> args = {
            "split",
            "-n", "r/" + std::to_string(num_files),
            input_file,
            output_prefix
        };
        
        if (!ExecuteSplitLib(args, state)) {
            CleanupFiles(output_prefix);
            unlink(input_file.c_str());
            return;
        }
        
        CleanupFiles(output_prefix);
        unlink(input_file.c_str());
    }
    
    state.SetBytesProcessed(state.iterations() * file_size);
}

// Register benchmarks with manual timing
BENCHMARK(BM_SplitLines)
    ->Args({1<<20, 100})       // 1MB file, 100 lines per file
    ->Args({1<<22, 1000})      // 4MB file, 1000 lines per file
    ->Args({1<<24, 10000})     // 16MB file, 10000 lines per file
    ->Unit(benchmark::kMillisecond)
    ->UseManualTime();

BENCHMARK(BM_SplitBytes)
    ->Args({1<<20, 1<<14})     // 1MB file, 16KB per file
    ->Args({1<<22, 1<<16})     // 4MB file, 64KB per file
    ->Args({1<<24, 1<<18})     // 16MB file, 256KB per file
    ->Unit(benchmark::kMillisecond)
    ->UseManualTime();

BENCHMARK(BM_SplitLineBytes)
    ->Args({1<<20, 1<<14})     // 1MB file, 16KB per file
    ->Args({1<<22, 1<<16})     // 4MB file, 64KB per file
    ->Args({1<<24, 1<<18})     // 16MB file, 256KB per file
    ->Unit(benchmark::kMillisecond)
    ->UseManualTime();

BENCHMARK(BM_SplitChunks)
    ->Args({1<<20, 5})         // 1MB file, 5 chunks
    ->Args({1<<22, 10})        // 4MB file, 10 chunks
    ->Args({1<<24, 20})        // 16MB file, 20 chunks
    ->Unit(benchmark::kMillisecond)
    ->UseManualTime();

BENCHMARK(BM_SplitRoundRobin)
    ->Args({1<<20, 3})         // 1MB file, 3 files
    ->Args({1<<22, 5})         // 4MB file, 5 files
    ->Args({1<<24, 8})         // 16MB file, 8 files
    ->Unit(benchmark::kMillisecond)
    ->UseManualTime();

int main(int argc, char** argv) {
    ::benchmark::Initialize(&argc, argv);
    if (::benchmark::ReportUnrecognizedArguments(argc, argv)) return 1;
    ::benchmark::RunSpecifiedBenchmarks();
    ::benchmark::Shutdown();
    return 0;
}